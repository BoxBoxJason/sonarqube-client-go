// Package generate handles the generation of the SonarQube client code.
package generate

//go:generate rm -f ../../sonar/*.go
//go:generate rm -rf ../../integration_testing
//go:generate sh -c "cd ../../ && go run ./cmd/main/main.go -f assets/api.json -n sonargo -o sonar -e http://127.0.0.1:9000/api -logtostderr=true -u admin -p admin"
//go:generate rm -rf ../../integration_testing
//go:generate sh -c "cd ../../ && go mod tidy"

import (
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/boxboxjason/sonarqube-client-go/pkg/api"
	"github.com/boxboxjason/sonarqube-client-go/pkg/response"
	"github.com/boxboxjason/sonarqube-client-go/pkg/util/strcase"
	. "github.com/dave/jennifer/jen"    //nolint:revive,staticcheck // Dot import for DSL
	_ "github.com/davecgh/go-spew/spew" // Blank import for side effects or debugging
	glog "github.com/magicsong/color-glog"
)

const (
	generatedHeader = "Code generated by `make generate`. DO NOT EDIT."
	pkgGinkgo       = "github.com/onsi/ginkgo"
	pkgGomega       = "github.com/onsi/gomega"
	pkgNetHTTP      = "net/http"
	respNoContent   = "no-content"
	headerFmt       = "// %s\n\npackage %s\n\n%s"
	methodGet       = "GET"
	formatJSON      = "json"
	formatProto     = "proto"
	formatLog       = "log"
	formatTxt       = "txt"
	formatSvg       = "svg"
	formatXML       = "xml"
	permDir         = 0o755
	permFile        = 0o644
	statusOK        = 200
	statusNoContent = 204
	logLevelDebug   = 3
)

// Generator handles the generation of the client code.
type Generator struct { //nolint:govet // Struct alignment is fine
	validation  *File
	client      *File
	fTestRun    *File
	WorkingDir  string
	PackageName string
	services    []string
	Endpoint    string
	Username    string
	Password    string
	CurrentRepo string
}

// NewGenerator creates a new Generator instance.
func NewGenerator(pkgName, workingDir, endpoint, username, password string) *Generator {
	return &Generator{
		WorkingDir:  workingDir,
		PackageName: pkgName,
		Endpoint:    endpoint,
		Username:    username,
		Password:    password,
		services:    make([]string, 0),
		validation:  nil,
		client:      nil,
		fTestRun:    nil,
		CurrentRepo: "",
	}
}

// Build constructs the generator and runs it.
func Build(pkgName, workingDir, endpoint, username, password string, apidoc *api.API) error {
	gen := NewGenerator(pkgName, workingDir, endpoint, username, password)

	return gen.Run(apidoc)
}

// Run executes the generation process.
func (gen *Generator) Run(apidoc *api.API) error {
	err := gen.prepare()
	if err != nil {
		return err
	}

	// add static file
	err = gen.AddStaticFile()
	if err != nil {
		glog.Errorln("Import static files failed")

		return err
	}

	for _, item := range apidoc.WebServices {
		err = gen.processService(item)
		if err != nil {
			return err
		}
	}

	err = gen.GenerateClient()
	if err != nil {
		glog.Errorln("Failed creating client codes")

		return err
	}

	// write test main
	err = gen.fTestRun.Save("integration_testing/run/zz_main.go")
	if err != nil {
		return fmt.Errorf("failed to save test run file: %w", err)
	}

	// Write validation file
	err = gen.validation.Save(gen.WorkingDir + "/zz_validation.go")
	if err != nil {
		return fmt.Errorf("failed to save validation file: %w", err)
	}

	return nil
}

// GenerateClient generates the client struct and constructor.
func (gen *Generator) GenerateClient() error {
	gen.client = NewFile(gen.PackageName)
	gen.client.HeaderComment(generatedHeader)
	gen.client.Type().Id("Client").StructFunc(func(group *Group) {
		group.Id("baseURL").Op("*").Qual("net/url", "URL")
		group.List(Id("username"), Id("password"), Id("token")).String()
		group.Id("authType").Id("authType")
		group.Id("httpClient").Op("*").Qual(pkgNetHTTP, "Client")

		for _, service := range gen.services {
			group.Id(strcase.ToCamel(service)).Op("*").Id(strcase.ToCamel(service) + "Service")
		}
	})

	gen.client.Func().Id("NewClient").Params(List(Id("endpoint"), Id("username"), Id("password")).String()).Params(Op("*").Id("Client"), Error()).BlockFunc(func(group *Group) {
		group.Id("c").Op(":=").Op("&Client{username: username, password: password, authType: basicAuth, httpClient: http.DefaultClient}")
		group.If(
			Id("endpoint").Op("==").Lit(""),
		).Block(
			Id("c").Dot("SetBaseURL").Call(Id("defaultBaseURL")),
		).Else().Block(
			If(Err().Op(" := c.SetBaseURL(endpoint); err != nil").Block(
				Return(Nil(), Err()),
			)),
		)

		for _, service := range gen.services {
			group.Id("c").Dot(strcase.ToCamel(service)).Op("=&").Id(strcase.ToCamel(service) + "Service").Values(Dict{Id("client"): Id("c")})
		}

		group.Return(Id("c"), Nil())
	})

	// Generate NewClientWithToken function
	gen.client.Func().Id("NewClientWithToken").Params(List(Id("endpoint"), Id("token")).String()).Params(Op("*").Id("Client"), Error()).BlockFunc(func(group *Group) {
		group.Id("c").Op(":=").Op("&Client{token: token, authType: privateToken, httpClient: http.DefaultClient}")
		group.If(
			Id("endpoint").Op("==").Lit(""),
		).Block(
			Id("c").Dot("SetBaseURL").Call(Id("defaultBaseURL")),
		).Else().Block(
			If(Err().Op(" := c.SetBaseURL(endpoint); err != nil").Block(
				Return(Nil(), Err()),
			)),
		)

		for _, service := range gen.services {
			group.Id("c").Dot(strcase.ToCamel(service)).Op("=&").Id(strcase.ToCamel(service) + "Service").Values(Dict{Id("client"): Id("c")})
		}

		group.Return(Id("c"), Nil())
	})

	err := gen.client.Save(gen.WorkingDir + "/zz_client.go")
	if err != nil {
		return fmt.Errorf("failed to save client file: %w", err)
	}

	return nil
}

// AddIntegrationFile generates integration tests for the service.
func (gen *Generator) AddIntegrationFile(service *api.WebService) error {
	serviceName := strcase.ToCamel(service.Path[4:])
	// set up

	file := NewFile(gen.PackageName + "_test")
	file.HeaderComment(generatedHeader)
	file.ImportName(gen.CurrentRepo, "")
	// construct

	file.Var().Id("_").Op("=").Qual(pkgGinkgo, "Describe").Call(Lit("SonarCLI integration test"), Func().Call().BlockFunc(func(group *Group) {
		group.Qual(pkgGinkgo, "BeforeEach").Call(Func().Call().Block())
		group.Qual(pkgGinkgo, "JustBeforeEach").Call(Func().Call().Block())

		for _, action := range service.Actions {
			gen.generateIntegrationTest(group, serviceName, service.Path, action)
		}
	}))

	err := file.Save("integration_testing/zz_" + service.Path[4:] + "_service_test.go")
	if err != nil {
		return fmt.Errorf("failed to save integration test file: %w", err)
	}

	return nil
}

// AddStaticFile adds static files to the generated package.
func (gen *Generator) AddStaticFile() error {
	s1 := fmt.Sprintf(headerFmt, generatedHeader, gen.PackageName, SonarqubeConst)
	webClientContent := fmt.Sprintf(headerFmt, generatedHeader, gen.PackageName, WebClientConst)
	SuiteStr := strings.Replace(TestSuiteConst, "{REPLACE_PACKAGENAME}", ". \"github.com/boxboxjason/sonarqube-client-go/sonar\"", 1)
	suiteContent := fmt.Sprintf("// %s\n\npackage %s_test\n\n%s", generatedHeader, gen.PackageName, SuiteStr)

	err := os.WriteFile(gen.WorkingDir+"/zz_sonarqube.go", []byte(s1), permFile)
	if err != nil {
		return fmt.Errorf("failed to write sonarqube.go: %w", err)
	}

	err = os.WriteFile("integration_testing/zz_sonarqube_suite_test.go", []byte(suiteContent), permFile)
	if err != nil {
		return fmt.Errorf("failed to write sonarqube_suite_test.go: %w", err)
	}

	// write core client and util files
	err = os.WriteFile(gen.WorkingDir+"/zz_client_util.go", []byte(webClientContent), permFile)
	if err != nil {
		return fmt.Errorf("failed to write client_util.go: %w", err)
	}

	// write generated tests for core client utilities
	ctBody := strings.ReplaceAll(ClientTestConst, "\r\n", "\n")
	ctBody = strings.ReplaceAll(ctBody, "\r", "\n")
	ct := fmt.Sprintf(headerFmt, generatedHeader, gen.PackageName, ctBody)

	err = os.WriteFile(gen.WorkingDir+"/zz_client_test.go", []byte(ct), permFile)
	if err != nil {
		return fmt.Errorf("failed to write client_test.go: %w", err)
	}

	cutBody := strings.ReplaceAll(ClientUtilTestConst, "\r\n", "\n")
	cutBody = strings.ReplaceAll(cutBody, "\r", "\n")
	cut := fmt.Sprintf(headerFmt, generatedHeader, gen.PackageName, cutBody)

	err = os.WriteFile(gen.WorkingDir+"/zz_client_util_test.go", []byte(cut), permFile)
	if err != nil {
		return fmt.Errorf("failed to write client_util_test.go: %w", err)
	}

	return nil
}

// AddServiceTestFile generates unit tests for a service using httptest mock server.
func (gen *Generator) AddServiceTestFile(service *api.WebService) error {
	if service == nil || len(service.Actions) == 0 {
		return nil
	}

	serviceName := service.Path[4:]
	serviceNameCamel := strcase.ToCamel(serviceName)

	file := NewFile(gen.PackageName)
	file.HeaderComment(generatedHeader)
	file.ImportName(pkgNetHTTP, "http")
	file.ImportName("net/http/httptest", "httptest")
	file.ImportName("testing", "testing")
	file.ImportName("encoding/json", "json")

	// Generate test for each action
	for _, action := range service.Actions {
		gen.generateActionTest(file, serviceNameCamel, action)
	}

	err := file.Save(gen.WorkingDir + "/zz_" + serviceName + "_service_test.go")
	if err != nil {
		return fmt.Errorf("failed to save service test file: %w", err)
	}

	return nil
}

// GenerateGoContent generates the Go code for the service.
func (gen *Generator) GenerateGoContent(packageName string, service *api.WebService) (*File, error) {
	if service == nil {
		return nil, errors.New("service must not be nil")
	}

	if packageName == "" {
		return nil, errors.New("package name is illegal")
	}

	file := NewFile(packageName)

	file.HeaderComment(generatedHeader)
	file.PackageComment(service.Description)
	file.ImportName("github.com/google/glog", "glog")

	name := service.Path[4:]
	// Create Service Struct
	file.Type().Id(strcase.ToCamel(name) + "Service").Struct(
		Id("client").Op("*").Id("Client"),
	).Line()

	// Process examples and generate structs
	gen.processExamples(file, service, name)

	// Create Methods
	for _, item := range service.Actions {
		file.Add(gen.generateServiceActionContent(name, &item))
	}

	return file, nil
}

// ErrorHandlerHelper generates error handling code.
func ErrorHandlerHelper(group *Group) {
	group.If(
		Err().Op("!=").Nil(),
	).Block(
		Return(),
	)
}

// GetCurrentModulePath reads the module path from go.mod file.
// This replaces the legacy GOPATH-based approach.
func GetCurrentModulePath() (string, error) {
	// Read go.mod file
	data, err := os.ReadFile("go.mod")
	if err != nil {
		return "", fmt.Errorf("failed to read go.mod: %w (make sure you're in a Go module directory)", err)
	}

	// Parse module path from go.mod
	lines := strings.SplitSeq(string(data), "\n")
	for line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			modulePath := strings.TrimSpace(strings.TrimPrefix(line, "module"))
			if modulePath == "" {
				return "", errors.New("module path is empty in go.mod")
			}

			return modulePath, nil
		}
	}

	return "", errors.New("module directive not found in go.mod")
}

func (gen *Generator) prepare() error {
	_ = os.Mkdir(gen.WorkingDir, permDir)
	_ = os.Mkdir("integration_testing", permDir)
	_ = os.Mkdir("integration_testing/run", permDir)

	var err error

	gen.CurrentRepo, err = GetCurrentModulePath()
	if err != nil {
		glog.Errorln("Failed to get the module path from go.mod")

		return err
	}

	// Append working directory to module path if it's not the root
	if gen.WorkingDir != "." && gen.WorkingDir != "" {
		gen.CurrentRepo = gen.CurrentRepo + "/" + gen.WorkingDir
	}

	// setup validation file
	gen.validation = NewFile(gen.PackageName)
	gen.validation.HeaderComment(generatedHeader)
	gen.validation.ImportName("github.com/boxboxjason/sonarqube-client-go/pkg/validation", "validation")

	// set up can-be-run test file
	gen.fTestRun = NewFile("main")
	gen.fTestRun.HeaderComment(generatedHeader)
	gen.fTestRun.ImportAlias(gen.CurrentRepo, ".")

	gen.fTestRun.Var().Id("client").Op("*").Qual(gen.CurrentRepo, "Client")

	staticCode := `sonarURL := os.Getenv("SONAR_URL")
if sonarURL == "" {
fmt.Println("Sonar URL has not been set")
os.Exit(1)
}
c, err := NewClient(sonarURL+"/api", "admin", "admin")
if err != nil {
fmt.Println(err.Error())
os.Exit(1)
}
client = c
`
	gen.fTestRun.Func().Id("init").Call().Block(Op(staticCode))
	gen.fTestRun.Comment("You should MANUALLY add the test func in here ")
	gen.fTestRun.Func().Id("main").Call().Block(Return())

	return nil
}

func (gen *Generator) processService(item api.WebService) error {
	name := item.Path[4:]
	// Skip empty service names
	if name == "" {
		glog.V(1).Infof("Skipping service with empty name: %s\n", item.Path)

		return nil
	}

	deprecatedWords := []string{"removed", "deprecated", "not_in_cli"}
	for _, word := range deprecatedWords {
		if strings.Contains(strings.ToLower(item.Description), word) {
			glog.V(1).Infof("Detected deprecated api:%s,source:%s\n", item.Path, item.Description)

			return nil
		}
	}

	gen.services = append(gen.services, name)
	newFile, err := os.Create(gen.WorkingDir + "/zz_" + name + "_service.go") //nolint:gosec
	glog.V(logLevelDebug).Infof("Creaing go file %s", newFile.Name())

	if err != nil {
		return fmt.Errorf("failed to create service file: %w", err)
	}

	defer func() { _ = newFile.Close() }()

	file, err := gen.GenerateGoContent(gen.PackageName, &item)
	if err != nil {
		return err
	}

	err = file.Render(newFile)
	if err != nil {
		return fmt.Errorf("failed to render service file: %w", err)
	}

	err = gen.AddIntegrationFile(&item)
	if err != nil {
		glog.Errorf("Failed to create integration_testing file of service %s", name)

		return err
	}

	// Generate unit tests for the service
	err = gen.AddServiceTestFile(&item)
	if err != nil {
		glog.Errorf("Failed to create unit test file for service %s", name)

		return err
	}

	return nil
}

func (gen *Generator) generateIntegrationTest(group *Group, serviceName, servicePath string, action api.Action) {
	actionName := strcase.ToCamel(action.Key)
	hasOption := true

	hasResp := true

	switch action.ResponseType {
	case formatJSON, formatTxt, formatLog, formatSvg, formatXML, formatProto:
		hasResp = true
	case respNoContent, "":
		hasResp = false
	default:
		if action.Post {
			hasResp = false
		} else {
			hasResp = true
		}
	}

	if len(action.Params) == 0 {
		hasOption = false
	}

	// generate code in test main
	gen.generateTestRunFunc(serviceName, actionName, action, hasOption, hasResp)

	// integration files
	group.Qual(pkgGinkgo, "Describe").Call(Lit("Test "+actionName+" in "+servicePath), Func().Call().BlockFunc(func(g1 *Group) {
		g1.Qual(pkgGinkgo, "PIt").Call(Lit("Should be ok"), Func().Call().BlockFunc(func(group *Group) {
			gen.generateGinkgoTestBody(group, serviceName, actionName, action, hasOption, hasResp)
		}))
	}))
}

func (gen *Generator) generateGinkgoTestBody(group *Group, serviceName, actionName string, action api.Action, hasOption, hasResp bool) {
	if hasOption {
		group.Id("opt").Op(":= &").Qual(gen.CurrentRepo, strcase.ToCamel(serviceName+"_"+action.Key+"Option")).Values(DictFunc(gen.generateOptionValues(action)))
		group.ListFunc(func(grp *Group) {
			if hasResp {
				grp.Id("v")
			}

			grp.Id("resp")
			grp.Err()
		}).Op(":=").Id("client").Dot(serviceName).Dot(actionName).Call(Id("opt"))
	} else {
		group.ListFunc(func(grp *Group) {
			if hasResp {
				grp.Id("v")
			}

			grp.Id("resp")
			grp.Err()
		}).Op(":=").Id("client").Dot(serviceName).Dot(actionName).Call()
	}

	group.Qual(pkgGomega, "Expect").Call(Err()).Dot("ShouldNot").Call(Qual(pkgGomega, "HaveOccurred").Call())

	group.Qual(pkgGomega, "Expect").Call(Id("resp").Dot("StatusCode")).Dot("To").Call(Qual(pkgGomega, "Equal").Call(Lit(statusOK)))

	if hasResp {
		group.Qual(pkgGomega, "Expect").Call(Op("*").Id("v")).Dot("To").Call(Qual(pkgGomega, "Equal").Call(Lit("MUST_EDIT_IT")))
	} else {
		group.Qual(pkgGomega, "Expect").Call(Id("resp").Dot("ContentLength")).Dot("To").Call(Qual(pkgGomega, "Equal").Call(Lit(0)))
	}
}

func (gen *Generator) generateTestRunFunc(serviceName, actionName string, action api.Action, hasOption, hasResp bool) {
	testFuncName := strcase.ToCamel(serviceName + actionName + "Func")
	gen.fTestRun.Commentf("%s testing %s", testFuncName, action.Description)
	gen.fTestRun.Func().Id(testFuncName).Call().BlockFunc(func(group *Group) {
		if hasOption {
			group.Id("opt").Op(":= &").Id(strcase.ToCamel(serviceName + "_" + action.Key + "Option")).Values(DictFunc(gen.generateOptionValues(action)))
			group.ListFunc(func(grp *Group) {
				if hasResp {
					grp.Id("v")
				}

				grp.Id("resp")
				grp.Err()
			}).Op(":=").Id("client").Dot(serviceName).Dot(actionName).Call(Id("opt"))
		} else {
			group.ListFunc(func(grp *Group) {
				if hasResp {
					grp.Id("v")
				}

				grp.Id("resp")
				grp.Err()
			}).Op(":=").Id("client").Dot(serviceName).Dot(actionName).Call()
		}

		group.If(
			Err().Op("!=").Nil(),
		).Block(
			Qual("fmt", "Println").Call(Err().Dot("Error").Call()),
			Qual("os", "Exit").Call(Id("1")),
		)
		group.Qual("fmt", "Println").Call(Id("resp").Dot("StatusCode"))

		if hasResp {
			group.Qual("github.com/davecgh/go-spew/spew", "Dump").Call(Id("v"))
		}
	})
	gen.fTestRun.Line()
}

func (gen *Generator) generateOptionValues(action api.Action) func(Dict) {
	return func(dict Dict) {
		for _, param := range action.Params {
			if detectDeprecatedField(&param) {
				continue
			}

			if param.Required {
				dict[Id(strcase.ToCamel(param.Key))] = Lit("MUST_EDIT_IT")
			} else {
				dict[Id(strcase.ToCamel(param.Key))] = Lit("")
			}
		}
	}
}

func (gen *Generator) generateActionTest(file *File, serviceNameCamel string, action api.Action) {
	actionName := strcase.ToCamel(action.Key)
	hasOption := len(action.Params) > 0

	// Determine if the method returns a response value (3 return values) or just (resp, err)
	// This must match the logic in GenerateGoContent
	method := methodGet
	if action.Post {
		method = "POST"
	}

	noResp := false

	switch action.ResponseType {
	case formatJSON, formatTxt, formatLog, formatSvg, formatXML, formatProto:
		noResp = false
	case respNoContent, "":
		noResp = true
	default:
		// For unknown response types, GET returns response, POST doesn't
		if method != methodGet {
			noResp = true
		}
	}

	hasResp := action.HasResponseExample || !action.Post
	isProto := action.ResponseType == formatProto

	testFuncName := "Test" + serviceNameCamel + "_" + actionName

	file.Func().Id(testFuncName).Params(Id("t").Op("*").Qual("testing", "T")).BlockFunc(func(group *Group) {
		// Create mock server
		gen.generateMockServer(group, method, isProto, noResp)
		gen.generateTestExecution(group, serviceNameCamel, actionName, hasOption, hasResp, noResp)
	})
	file.Line()
}

//nolint:nestif
func (gen *Generator) generateTestExecution(group *Group, serviceNameCamel, actionName string, hasOption, hasResp, noResp bool) {
	// Create client pointing to mock server
	group.Comment("Create client pointing to mock server")
	group.List(Id("client"), Id("err")).Op(":=").Id("NewClient").Call(Id("ts").Dot("URL").Op("+").Lit("/api/"), Lit("user"), Lit("pass"))
	group.If(Err().Op("!=").Nil()).Block(
		Id("t").Dot("Fatalf").Call(Lit("failed to create client: %v"), Err()),
	)

	// Call the service method
	group.Comment("Call service method")

	if hasOption {
		group.Id("opt").Op(":=").Op("&").Id(serviceNameCamel + strcase.ToCamel(actionName) + "Option").Values()

		if hasResp {
			group.List(Id("_"), Id("resp"), Id("err")).Op(":=").Id("client").Dot(serviceNameCamel).Dot(actionName).Call(Id("opt"))
		} else {
			group.List(Id("resp"), Id("err")).Op(":=").Id("client").Dot(serviceNameCamel).Dot(actionName).Call(Id("opt"))
		}
	} else {
		if hasResp {
			group.List(Id("_"), Id("resp"), Id("err")).Op(":=").Id("client").Dot(serviceNameCamel).Dot(actionName).Call()
		} else {
			group.List(Id("resp"), Id("err")).Op(":=").Id("client").Dot(serviceNameCamel).Dot(actionName).Call()
		}
	}

	group.If(Err().Op("!=").Nil()).Block(
		Id("t").Dot("Fatalf").Call(Lit(actionName+" failed: %v"), Err()),
	)
	// Check expected status code
	expectedStatus := statusOK
	if noResp {
		expectedStatus = statusNoContent
	}

	group.If(Id("resp").Dot("StatusCode").Op("!=").Lit(expectedStatus)).Block(
		Id("t").Dot("Errorf").Call(Lit(fmt.Sprintf("expected status %d, got %%d", expectedStatus)), Id("resp").Dot("StatusCode")),
	)
}

func (gen *Generator) generateMockServer(group *Group, method string, isProto, noResp bool) {
	group.Comment("Create mock server")
	group.Id("ts").Op(":=").Qual("net/http/httptest", "NewServer").Call(
		Qual(pkgNetHTTP, "HandlerFunc").Call(
			Func().Params(Id("w").Qual(pkgNetHTTP, "ResponseWriter"), Id("r").Op("*").Qual(pkgNetHTTP, "Request")).BlockFunc(func(handlerGroup *Group) {
				handlerGroup.Comment("Verify request method")
				handlerGroup.If(Id("r").Dot("Method").Op("!=").Lit(method)).Block(
					Id("t").Dot("Errorf").Call(Lit("expected method "+method+", got %s"), Id("r").Dot("Method")),
				)
				handlerGroup.Comment("Return mock response")

				switch {
				case isProto:
					// For proto responses, return 200 with valid JSON empty array
					// The Do function uses json.Decode for []byte type
					handlerGroup.Id("w").Dot("Header").Call().Dot("Set").Call(Lit("Content-Type"), Lit("application/json"))
					handlerGroup.Id("w").Dot("WriteHeader").Call(Lit(statusOK))
					handlerGroup.Id("w").Dot("Write").Call(Index().Byte().Call(Lit("[]")))
				case noResp:
					// No response body expected
					handlerGroup.Id("w").Dot("WriteHeader").Call(Lit(statusNoContent))
				default:
					// Use null for JSON which is valid for any pointer/slice type
					handlerGroup.Id("w").Dot("Header").Call().Dot("Set").Call(Lit("Content-Type"), Lit("application/json"))
					handlerGroup.Id("w").Dot("WriteHeader").Call(Lit(statusOK))
					handlerGroup.Id("w").Dot("Write").Call(Index().Byte().Call(Lit("null")))
				}
			}),
		),
	)
	group.Defer().Id("ts").Dot("Close").Call()
}

func (gen *Generator) processExamples(file *File, service *api.WebService, name string) {
	fetcher := response.NewExampleFetcher(gen.Endpoint, gen.Username, gen.Password)

	examples, err := fetcher.GetResponseExample(service)
	if err != nil {
		glog.Warningf("cannot fetch examples of <%s>: %v (continuing without examples)", service.Path, err)

		examples = make([]*response.WebservicesResponseExampleResp, 0)
	}

	// Always set default response types for actions that didn't get one from examples
	gen.setDefaultResponseTypes(file, service, name)

	for _, exam := range examples {
		if exam.Format == formatProto {
			glog.V(1).Infof("The response of action <%s> for api <%s> is proto, using []byte", exam.Name, name)
			gen.setProtoResponseType(service, exam.Name)

			continue
		}

		if exam.Format != formatJSON {
			glog.V(1).Infof("The response of action <%s> for api <%s> is %s, not json", exam.Name, name, exam.Format)

			continue
		}

		if exam.Example != "" {
			gen.generateStructFromExample(file, service, name, exam)
		}
	}
}

func (gen *Generator) setDefaultResponseTypes(file *File, service *api.WebService, name string) {
	for idx := range service.Actions {
		if service.Actions[idx].ResponseType == "" {
			if service.Actions[idx].Post {
				service.Actions[idx].ResponseType = respNoContent
			} else {
				service.Actions[idx].ResponseType = formatJSON
				respName := strcase.ToCamel(name + "_" + service.Actions[idx].Key + "Object")
				file.Commentf("[TODO] cannot fetch response example for <%s>, struct needs to be filled manually", service.Actions[idx].Key)
				file.Type().Id(respName).Struct().Line()
			}
		}
	}
}

func (gen *Generator) setProtoResponseType(service *api.WebService, actionName string) {
	for idx := range service.Actions {
		if service.Actions[idx].Key == actionName {
			service.Actions[idx].ResponseType = formatProto

			break
		}
	}
}

func (gen *Generator) generateStructFromExample(file *File, service *api.WebService, name string, exam *response.WebservicesResponseExampleResp) {
	respName := strcase.ToCamel(name + "_" + exam.Name + "Object")

	stru, err := ConvertStringToStruct(exam.Example, respName)
	if err != nil {
		glog.Warningf("cannot generate resp struct of <%s>,you should manual edit the file %s,esspecial method response", service.Path, gen.WorkingDir+"/zz_"+name+"_service.go")
		glog.Errorln(err.Error())
		file.Commentf("[TODO] cannot generate resp struct of <%s>,you should manual edit the file %s,esspecial method response", service.Path, gen.WorkingDir+"/zz_"+name+"_service.go")
		file.Type().Id(respName).Struct().Line()
	} else {
		file.Id(stru).Line()
		file.Line()
	}
}

func detectDeprecatedField(field *api.Param) bool {
	return strings.Contains(strings.ToLower(field.Description), "deprecated")
}

// generateServiceActionContent generate code of each service,include api method and related structs.
func (gen *Generator) generateServiceActionContent(serviceName string, action *api.Action) *Statement {
	code := Line()
	hasOption := len(action.Params) > 0
	optionName := strcase.ToCamel(serviceName + "_" + action.Key + "Option")

	if hasOption {
		gen.generateOptionStruct(code, action, optionName, serviceName)
	}

	gen.generateServiceMethod(code, serviceName, action, hasOption, optionName)

	return code
}

func (gen *Generator) generateOptionStruct(code *Statement, action *api.Action, optionName, serviceName string) {
	code.Type().Id(optionName).StructFunc(func(group *Group) {
		for _, field := range action.Params {
			if detectDeprecatedField(&field) {
				glog.V(1).Infof("Detected deprecated field <%s> in <action>:%s,description:%s\n", field.Key, action.Key, field.Description)

				continue
			}

			group.Id(strcase.ToCamel(field.Key)).String().Tag(map[string]string{"url": field.Key + ",omitempty"}).Commentf("Description:\"%s\",ExampleValue:\"%s\"", field.Description, field.ExampleValue)
		}
	}).Line()

	// create valid method
	gen.validation.Func().Params(Id("s").Op("*").Id(strcase.ToCamel(serviceName) + "Service")).Id("Validate" + strcase.ToCamel(action.Key) + "Opt").Params(
		Id("opt").Op("*").Id(optionName)).Params(Error()).Block(
		Return(Nil()),
	)
}

func (gen *Generator) generateServiceMethod(code *Statement, serviceName string, action *api.Action, hasOption bool, optionName string) {
	respName := strcase.ToCamel(serviceName + "_" + action.Key + "Object")
	method := methodGet
	noResp := false

	if action.Post {
		method = "POST"
	}

	code.Commentf("%s %s", strcase.ToCamel(action.Key), action.Description).Line()
	code.Func().Params(Id("s").Op("*").Id(strcase.ToCamel(serviceName) + "Service")).Id(strcase.ToCamel(action.Key)).ParamsFunc(func(group *Group) {
		if hasOption {
			group.Id("opt").Op("*").Id(optionName)
		}
	}).ParamsFunc(func(group *Group) {
		switch action.ResponseType {
		case formatJSON:
			group.Id("v").Op("*").Id(respName)
		case formatTxt, formatLog, formatSvg, formatXML:
			group.Id("v").Op("*").String()

			respName = "string"
		case formatProto:
			// Protocol Buffer binary data
			group.Id("v").Op("[]").Byte()

			respName = "[]byte"
		case respNoContent, "":
			// No response body expected
			noResp = true
		default:
			if method == methodGet {
				group.Id("v").Op("*").Id(respName)
			} else {
				noResp = true
			}
		}

		group.Id("resp").Op("*").Qual(pkgNetHTTP, "Response")
		group.Err().Error()
	}).BlockFunc(func(group *Group) {
		gen.generateServiceMethodBody(group, serviceName, action, hasOption, method, noResp, respName)
	})
}

func (gen *Generator) generateServiceMethodBody(group *Group, serviceName string, action *api.Action, hasOption bool, method string, noResp bool, respName string) {
	if hasOption {
		group.Err().Op("=").Id("s").Dot("Validate" + strcase.ToCamel(action.Key) + "Opt").Call(Id("opt"))
		ErrorHandlerHelper(group)
	}

	group.List(Id("req"), Id("err")).Op(":=").Id("s").Dot("client").Dot("NewRequest").CallFunc(func(reqGroup *Group) {
		reqGroup.Lit(method)
		reqGroup.Lit(serviceName + "/" + action.Key)

		if hasOption {
			reqGroup.Id("opt")
		} else {
			reqGroup.Nil()
		}
	})
	ErrorHandlerHelper(group)

	switch {
	case noResp:
		group.List(Id("resp"), Err()).Op("=").Id("s").Dot("client").Dot("Do").Call(Id("req"), Nil())
		ErrorHandlerHelper(group)
	case action.ResponseType == formatProto:
		// For proto responses, don't use New() since v is []byte not a pointer
		group.List(Id("resp"), Err()).Op("=").Id("s").Dot("client").Dot("Do").Call(Id("req"), Op("&").Id("v"))
		group.If(
			Err().Op("!=").Nil(),
		).Block(
			Return().List(Nil(), Id("resp"), Err()),
		)
	default:
		group.Id("v").Op("=").New(Id(respName))
		group.List(Id("resp"), Err()).Op("=").Id("s").Dot("client").Dot("Do").Call(Id("req"), Id("v"))
		group.If(
			Err().Op("!=").Nil(),
		).Block(
			Return().List(Nil(), Id("resp"), Err()),
		)
	}

	group.Return()
}
