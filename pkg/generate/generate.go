// Package generate handles the generation of the SonarQube client code.
package generate

//go:generate rm -f ../../sonar/*.go
//go:generate sh -c "cd ../../ && go run ./cmd/main/main.go -f assets/api.json -n sonargo -o sonar -e http://127.0.0.1:9000/api -logtostderr=true -u admin -p admin"
//go:generate sh -c "cd ../../ && go mod tidy"

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/boxboxjason/sonarqube-client-go/pkg/api"
	jen "github.com/dave/jennifer/jen"
	_ "github.com/davecgh/go-spew/spew" // Blank import for side effects or debugging
	glog "github.com/magicsong/color-glog"
)

const (
	generatedHeader = "Code generated by `make generate`. DO NOT EDIT."
	// GeneratedFilenamePrefix is the prefix for generated filenames.
	GeneratedFilenamePrefix = "zz_"
	pkgGinkgo               = "github.com/onsi/ginkgo"
	pkgGomega               = "github.com/onsi/gomega"
	pkgNetHTTP              = "net/http"
	respNoContent           = "no-content"
	headerFmt               = "// %s\n\npackage %s\n\n%s"
	methodGet               = "GET"
	formatJSON              = "json"
	formatProto             = "proto"
	formatLog               = "log"
	formatTxt               = "txt"
	formatSvg               = "svg"
	formatXML               = "xml"
	permDir                 = 0o755
	permFile                = 0o644
	statusOK                = 200
	statusNoContent         = 204
	logLevelDebug           = 3
)

// Generator handles the generation of the client code.
type Generator struct { //nolint:govet // jen.Struct alignment is fine
	validation  *jen.File
	client      *jen.File
	fTestRun    *jen.File
	WorkingDir  string
	PackageName string
	services    []string
	Endpoint    string
	Username    string
	Password    string
	CurrentRepo string

	specificValues   map[string]string
	skipParams       map[string]bool
	skipActions      map[string]bool
	explicitMappings map[string]string
}

// NewGenerator creates a new Generator instance.
func NewGenerator(pkgName, workingDir, endpoint, username, password string) *Generator {
	return &Generator{
		WorkingDir:       workingDir,
		PackageName:      pkgName,
		Endpoint:         endpoint,
		Username:         username,
		Password:         password,
		services:         make([]string, 0),
		validation:       nil,
		client:           nil,
		fTestRun:         nil,
		CurrentRepo:      "",
		specificValues:   loadSpecificValues(),
		skipParams:       loadSkipParams(),
		skipActions:      loadSkipActions(),
		explicitMappings: loadExplicitMappings(),
	}
}

// Build constructs the generator and runs it.
func Build(pkgName, workingDir, endpoint, username, password string, apidoc *api.API) error {
	gen := NewGenerator(pkgName, workingDir, endpoint, username, password)

	return gen.Run(apidoc)
}

// Run executes the generation process.
func (gen *Generator) Run(apidoc *api.API) error {
	err := gen.prepare()
	if err != nil {
		return err
	}

	gen.cleanupGeneratedFiles()

	// add static file
	err = gen.AddStaticFile()
	if err != nil {
		glog.Errorln("Import static files failed")

		return err
	}

	// add integration suite file
	err = gen.AddIntegrationSuiteFile()
	if err != nil {
		glog.Errorln("Import integration suite file failed")

		return err
	}

	for _, item := range apidoc.WebServices {
		err = gen.processService(item)
		if err != nil {
			return err
		}
	}

	err = gen.GenerateClient()
	if err != nil {
		glog.Errorln("Failed creating client codes")

		return err
	}

	// write test main
	err = gen.fTestRun.Save("integration_testing/run/" + GeneratedFilenamePrefix + "main.go")
	if err != nil {
		return fmt.Errorf("failed to save test run file: %w", err)
	}

	// Write validation file
	err = gen.validation.Save(gen.WorkingDir + "/" + GeneratedFilenamePrefix + "validation.go")
	if err != nil {
		return fmt.Errorf("failed to save validation file: %w", err)
	}

	return nil
}

// GetCurrentModulePath reads the module path from go.mod file.
// This replaces the legacy GOPATH-based approach.
func GetCurrentModulePath() (string, error) {
	// Read go.mod file
	data, err := os.ReadFile("go.mod")
	if err != nil {
		return "", fmt.Errorf("failed to read go.mod: %w (make sure you're in a Go module directory)", err)
	}

	// Parse module path from go.mod
	lines := strings.SplitSeq(string(data), "\n")
	for line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			modulePath := strings.TrimSpace(strings.TrimPrefix(line, "module"))
			if modulePath == "" {
				return "", errors.New("module path is empty in go.mod")
			}

			return modulePath, nil
		}
	}

	return "", errors.New("module directive not found in go.mod")
}

// AddStaticFile adds static files to the generated code.
func (gen *Generator) AddStaticFile() error {
	// Write client.go
	clientBody := strings.ReplaceAll(SonarqubeConst, "\r\n", "\n")
	clientBody = strings.ReplaceAll(clientBody, "\r", "\n")
	clientContent := fmt.Sprintf(headerFmt, generatedHeader, gen.PackageName, clientBody)

	err := os.WriteFile(gen.WorkingDir+"/"+GeneratedFilenamePrefix+"client.go", []byte(clientContent), permFile)
	if err != nil {
		return fmt.Errorf("failed to write client.go: %w", err)
	}

	// Write client_util.go
	utilBody := strings.ReplaceAll(WebClientConst, "\r\n", "\n")
	utilBody = strings.ReplaceAll(utilBody, "\r", "\n")
	utilContent := fmt.Sprintf(headerFmt, generatedHeader, gen.PackageName, utilBody)

	err = os.WriteFile(gen.WorkingDir+"/"+GeneratedFilenamePrefix+"client_util.go", []byte(utilContent), permFile)
	if err != nil {
		return fmt.Errorf("failed to write client_util.go: %w", err)
	}

	return nil
}

func (gen *Generator) processService(item api.WebService) error {
	name := item.Path[4:]
	// Skip empty service names
	if name == "" {
		glog.V(1).Infof("Skipping service with empty name: %s\n", item.Path)

		return nil
	}

	deprecatedWords := []string{"removed", "deprecated", "not_in_cli"}
	for _, word := range deprecatedWords {
		if strings.Contains(strings.ToLower(item.Description), word) {
			glog.V(1).Infof("Detected deprecated api:%s,source:%s\n", item.Path, item.Description)

			return nil
		}
	}

	gen.services = append(gen.services, name)
	newFile, err := os.Create(gen.WorkingDir + "/" + GeneratedFilenamePrefix + name + "_service.go") //nolint:gosec
	glog.V(logLevelDebug).Infof("Creaing go file %s", newFile.Name())

	if err != nil {
		return fmt.Errorf("failed to create service file: %w", err)
	}

	defer func() { _ = newFile.Close() }()

	file, err := gen.GenerateGoContent(gen.PackageName, &item)
	if err != nil {
		return err
	}

	err = file.Render(newFile)
	if err != nil {
		return fmt.Errorf("failed to render service file: %w", err)
	}

	err = gen.AddIntegrationFile(&item)
	if err != nil {
		glog.Errorf("Failed to create integration_testing file of service %s", name)

		return err
	}

	// Generate unit tests for the service
	err = gen.AddServiceTestFile(&item)
	if err != nil {
		glog.Errorf("Failed to create unit test file for service %s", name)

		return err
	}

	return nil
}

func (gen *Generator) prepare() error {
	_ = os.Mkdir(gen.WorkingDir, permDir)
	_ = os.Mkdir("integration_testing", permDir)
	_ = os.Mkdir("integration_testing/run", permDir)

	var err error

	gen.CurrentRepo, err = GetCurrentModulePath()
	if err != nil {
		glog.Errorln("Failed to get the module path from go.mod")

		return err
	}

	// Append working directory to module path if it's not the root
	if gen.WorkingDir != "." && gen.WorkingDir != "" {
		gen.CurrentRepo = gen.CurrentRepo + "/" + gen.WorkingDir
	}

	// setup validation file
	gen.validation = jen.NewFile(gen.PackageName)
	gen.validation.HeaderComment(generatedHeader)
	gen.validation.ImportName("github.com/boxboxjason/sonarqube-client-go/pkg/validation", "validation")

	// set up can-be-run test file
	gen.fTestRun = jen.NewFile("main")
	gen.fTestRun.HeaderComment(generatedHeader)
	gen.fTestRun.ImportAlias(gen.CurrentRepo, ".")

	gen.fTestRun.Var().Id("client").Op("*").Qual(gen.CurrentRepo, "Client")

	staticCode := `sonarURL := os.Getenv("SONAR_URL")
if sonarURL == "" {
fmt.Println("Sonar URL has not been set")
os.Exit(1)
}
c, err := NewClient(sonarURL+"/api", "admin", "admin")
if err != nil {
fmt.Println(err.Error())
os.Exit(1)
}
client = c
`
	gen.fTestRun.Func().Id("init").Call().Block(jen.Op(staticCode))
	gen.fTestRun.Comment("You should MANUALLY add the test func in here ")
	gen.fTestRun.Func().Id("main").Call().Block(jen.Return())

	return nil
}

func (gen *Generator) cleanupGeneratedFiles() {
	// Clean up existing generated integration tests
	files, err := filepath.Glob("integration_testing/" + GeneratedFilenamePrefix + "*.go")
	if err == nil {
		for _, f := range files {
			removeErr := os.Remove(f)
			if removeErr != nil {
				glog.Warningf("Failed to remove generated file %s: %v", f, removeErr)
			}
		}
	}
}
