package generate

//go:generate rm -f ../../sonar/*.go
//go:generate rm -rf ../../integration_testing
//go:generate sh -c "cd ../../ && go run ./cmd/main/main.go -f assets/api.json -n sonargo -o sonar -e http://127.0.0.1:9000/api -logtostderr=true -u admin -p admin"
//go:generate rm -rf ../../integration_testing
//go:generate sh -c "cd ../../ && go mod tidy"

import (
	"errors"
	"fmt"
	"os"
	"strings"

	_ "github.com/davecgh/go-spew/spew"

	. "github.com/dave/jennifer/jen"
	glog "github.com/magicsong/color-glog"

	"github.com/boxboxjason/sonarqube-client-go/pkg/api"
	"github.com/boxboxjason/sonarqube-client-go/pkg/response"
	"github.com/boxboxjason/sonarqube-client-go/pkg/util/strcase"
)

const generatedHeader = "Code generated by `make generate`. DO NOT EDIT."

var (
	DeprecatedWords = []string{"removed", "deprecated", "not_in_cli"}
	validation      *File
	client          *File
	fTestRun        *File
	WorkingDir      string
	PackageName     string
	services        []string
	Endpoint        string
	Username        string
	Password        string
	CurrentRepo     string
)

func init() {
	services = make([]string, 0)
}
func GenerateClient() error {
	client = NewFile(PackageName)
	client.HeaderComment(generatedHeader)
	client.Type().Id("Client").StructFunc(func(g *Group) {
		g.Id("baseURL").Op("*").Qual("net/url", "URL")
		g.List(Id("username"), Id("password"), Id("token")).String()
		g.Id("authType").Id("authType")
		g.Id("httpClient").Op("*").Qual("net/http", "Client")
		for _, service := range services {
			g.Id(strcase.ToCamel(service)).Op("*").Id(strcase.ToCamel(service) + "Service")
		}
	})
	client.Func().Id("NewClient").Params(List(Id("endpoint"), Id("username"), Id("password")).String()).Params(Op("*").Id("Client"), Error()).BlockFunc(func(g *Group) {
		g.Id("c").Op(":=").Op("&Client{username: username, password: password, authType: basicAuth, httpClient: http.DefaultClient}")
		g.If(
			Id("endpoint").Op("==").Lit(""),
		).Block(
			Id("c").Dot("SetBaseURL").Call(Id("defaultBaseURL")),
		).Else().Block(
			If(Err().Op(" := c.SetBaseURL(endpoint); err != nil").Block(
				Return(Nil(), Err()),
			)),
		)
		for _, service := range services {
			g.Id("c").Dot(strcase.ToCamel(service)).Op("=&").Id(strcase.ToCamel(service) + "Service").Values(Dict{Id("client"): Id("c")})
		}
		g.Return(Id("c"), Nil())
	})
	// Generate NewClientWithToken function
	client.Func().Id("NewClientWithToken").Params(List(Id("endpoint"), Id("token")).String()).Params(Op("*").Id("Client"), Error()).BlockFunc(func(g *Group) {
		g.Id("c").Op(":=").Op("&Client{token: token, authType: privateToken, httpClient: http.DefaultClient}")
		g.If(
			Id("endpoint").Op("==").Lit(""),
		).Block(
			Id("c").Dot("SetBaseURL").Call(Id("defaultBaseURL")),
		).Else().Block(
			If(Err().Op(" := c.SetBaseURL(endpoint); err != nil").Block(
				Return(Nil(), Err()),
			)),
		)
		for _, service := range services {
			g.Id("c").Dot(strcase.ToCamel(service)).Op("=&").Id(strcase.ToCamel(service) + "Service").Values(Dict{Id("client"): Id("c")})
		}
		g.Return(Id("c"), Nil())
	})
	return client.Save(WorkingDir + "/zz_client.go")
}
func prepare(pkgName, workingDir, endpoint, username, password string) error {
	WorkingDir = workingDir
	PackageName = pkgName
	Endpoint = endpoint
	Username = username
	Password = password
	_ = os.Mkdir(workingDir, 0755)
	_ = os.Mkdir("integration_testing", 0755)
	_ = os.Mkdir("integration_testing/run", 0755)

	CurrentRepo, err := GetCurrentModulePath()
	if err != nil {
		glog.Errorln("Failed to get the module path from go.mod")
		return err
	}
	// Append working directory to module path if it's not the root
	if workingDir != "." && workingDir != "" {
		CurrentRepo = CurrentRepo + "/" + workingDir
	}
	//setup validation file
	validation = NewFile(pkgName)
	validation.HeaderComment(generatedHeader)
	validation.ImportName("github.com/boxboxjason/sonarqube-client-go/pkg/validation", "validation")
	//set up can-be-run test file
	fTestRun = NewFile("main")
	fTestRun.HeaderComment(generatedHeader)
	fTestRun.ImportAlias(CurrentRepo, ".")

	fTestRun.Var().Id("client").Op("*").Qual(CurrentRepo, "Client")
	staticCode := `sonarURL := os.Getenv("SONAR_URL")
	if sonarURL == "" {
		fmt.Println("Sonar URL has not been set")
		os.Exit(1)
	}
	c, err := NewClient(sonarURL+"/api", "admin", "admin")
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
	client = c
	`
	fTestRun.Func().Id("init").Call().Block(Op(staticCode))
	fTestRun.Comment("You should MANUALLY add the test func in here ")
	fTestRun.Func().Id("main").Call().Block(Return())
	return nil
}
func Build(pkgName, workingDir, endpoint, username, password string, apidoc *api.API) error {
	err := prepare(pkgName, workingDir, endpoint, username, password)
	if err != nil {
		return err
	}
	// add static file
	err = AddStaticFile()
	if err != nil {
		glog.Errorln("Import static files failed")
		return err
	}
	for _, item := range apidoc.WebServices {
		name := item.Path[4:]
		// Skip empty service names
		if name == "" {
			glog.V(1).Infof("Skipping service with empty name: %s\n", item.Path)
			continue
		}
		contin := false
		for _, word := range DeprecatedWords {
			if strings.Contains(strings.ToLower(item.Description), word) {
				glog.V(1).Infof("Detected deprecated api:%s,source:%s\n", item.Path, item.Description)
				contin = true
				break
			}
		}
		if contin {
			continue
		}
		services = append(services, name)
		newFile, err := os.Create(workingDir + "/zz_" + name + "_service.go")
		glog.V(3).Infof("Creaing go file %s", newFile.Name())
		if err != nil {
			return err
		}
		defer newFile.Close()
		f, err := GenerateGoContent(PackageName, &item)
		if err != nil {
			return err
		}
		err = f.Render(newFile)
		if err != nil {
			return err
		}
		err = AddIntegrationFile(&item)
		if err != nil {
			glog.Errorf("Failed to create integration_testing file of service %s", name)
			return err
		}
		// Generate unit tests for the service
		err = AddServiceTestFile(&item)
		if err != nil {
			glog.Errorf("Failed to create unit test file for service %s", name)
			return err
		}
	}
	if err = GenerateClient(); err != nil {
		glog.Errorln("Failed creating client codes")
		return err
	}
	//write test main
	err = fTestRun.Save("integration_testing/run/zz_main.go")
	if err != nil {
		return err
	}
	//Write validation file
	return validation.Save(WorkingDir + "/zz_validation.go")
}

func AddIntegrationFile(service *api.WebService) error {
	serviceName := strcase.ToCamel(service.Path[4:])
	//set up

	f := NewFile(PackageName + "_test")
	f.HeaderComment(generatedHeader)
	f.ImportName(CurrentRepo, "")
	//construct

	f.Var().Id("_").Op("=").Qual("github.com/onsi/ginkgo", "Describe").Call(Lit("SonarCLI integration test"), Func().Call().BlockFunc(func(g *Group) {
		g.Qual("github.com/onsi/ginkgo", "BeforeEach").Call(Func().Call().Block())
		g.Qual("github.com/onsi/ginkgo", "JustBeforeEach").Call(Func().Call().Block())
		for _, action := range service.Actions {
			actionName := strcase.ToCamel(action.Key)
			hasOption := true
			hasResp := true
			if !action.HasResponseExample && action.Post {
				hasResp = false
			}
			if len(action.Params) == 0 {
				hasOption = false
			}

			//generate code in test main
			testFuncName := strcase.ToCamel(serviceName + actionName + "Func")
			fTestRun.Commentf("%s testing %s", testFuncName, action.Description)
			fTestRun.Func().Id(testFuncName).Call().BlockFunc(func(g2 *Group) {
				if hasOption {
					g2.Id("opt").Op(":= &").Id(strcase.ToCamel(serviceName + "_" + action.Key + "Option")).Values(DictFunc(func(d Dict) {
						for _, param := range action.Params {
							if detectDeprecatedField(&param) {
								continue
							}
							if param.Required {
								d[Id(strcase.ToCamel(param.Key))] = Lit("MUST_EDIT_IT")
							} else {
								d[Id(strcase.ToCamel(param.Key))] = Lit("")
							}
						}
					}))
					g2.ListFunc(func(g *Group) {
						if hasResp {
							g.Id("v")
						}
						g.Id("resp")
						g.Err()
					}).Op(":=").Id("client").Dot(serviceName).Dot(actionName).Call(Id("opt"))
				} else {
					g2.ListFunc(func(g *Group) {
						if hasResp {
							g.Id("v")
						}
						g.Id("resp")
						g.Err()
					}).Op(":=").Id("client").Dot(serviceName).Dot(actionName).Call()
				}
				g2.If(
					Err().Op("!=").Nil(),
				).Block(
					Qual("fmt", "Println").Call(Err().Dot("Error").Call()),
					Qual("os", "Exit").Call(Id("1")),
				)
				g2.Qual("fmt", "Println").Call(Id("resp").Dot("StatusCode"))
				if hasResp {
					g2.Qual("github.com/davecgh/go-spew/spew", "Dump").Call(Id("v"))
				}
			})
			fTestRun.Line()
			// integration files
			g.Qual("github.com/onsi/ginkgo", "Describe").Call(Lit("Test "+actionName+" in "+service.Path), Func().Call().BlockFunc(func(g1 *Group) {
				g1.Qual("github.com/onsi/ginkgo", "PIt").Call(Lit("Should be ok"), Func().Call().BlockFunc(func(g2 *Group) {
					if hasOption {
						g2.Id("opt").Op(":= &").Qual(CurrentRepo, strcase.ToCamel(serviceName+"_"+action.Key+"Option")).Values(DictFunc(func(d Dict) {
							for _, param := range action.Params {
								if detectDeprecatedField(&param) {
									continue
								}
								if param.Required {
									d[Id(strcase.ToCamel(param.Key))] = Lit("MUST_EDIT_IT")
								} else {
									d[Id(strcase.ToCamel(param.Key))] = Lit("")
								}
							}
						}))
						g2.ListFunc(func(g *Group) {
							if hasResp {
								g.Id("v")
							}
							g.Id("resp")
							g.Err()
						}).Op(":=").Id("client").Dot(serviceName).Dot(actionName).Call(Id("opt"))
					} else {
						g2.ListFunc(func(g *Group) {
							if hasResp {
								g.Id("v")
							}
							g.Id("resp")
							g.Err()
						}).Op(":=").Id("client").Dot(serviceName).Dot(actionName).Call()
					}
					g2.Qual("github.com/onsi/gomega", "Expect").Call(Err()).Dot("ShouldNot").Call(Qual("github.com/onsi/gomega", "HaveOccurred").Call())
					g2.Qual("github.com/onsi/gomega", "Expect").Call(Id("resp").Dot("StatusCode")).Dot("To").Call(Qual("github.com/onsi/gomega", "Equal").Call(Id("200")))
					if hasResp {
						g2.Qual("github.com/onsi/gomega", "Expect").Call(Op("*").Id("v")).Dot("To").Call(Qual("github.com/onsi/gomega", "Equal").Call(Lit("MUST_EDIT_IT")))
					} else {
						g2.Qual("github.com/onsi/gomega", "Expect").Call(Id("resp").Dot("ContentLength")).Dot("To").Call(Qual("github.com/onsi/gomega", "Equal").Call(Id("0")))
					}
				}))
			}))
		}
	}))
	return f.Save("integration_testing/zz_" + service.Path[4:] + "_service_test.go")
}
func AddStaticFile() error {
	s1 := fmt.Sprintf("// %s\n\npackage %s\n\n%s", generatedHeader, PackageName, SonarqubeConst)
	s2 := fmt.Sprintf("// %s\n\npackage %s\n\n%s", generatedHeader, PackageName, WebClientConst)
	SuiteStr := strings.Replace(TestSuiteConst, "{REPLACE_PACKAGENAME}", ". \"github.com/boxboxjason/sonarqube-client-go/sonar\"", 1)
	s3 := fmt.Sprintf("// %s\n\npackage %s_test\n\n%s", generatedHeader, PackageName, SuiteStr)
	err := os.WriteFile(WorkingDir+"/zz_sonarqube.go", []byte(s1), 0644)
	if err != nil {
		return err
	}
	err = os.WriteFile("integration_testing/zz_sonarqube_suite_test.go", []byte(s3), 0644)
	if err != nil {
		return err
	}
	// write core client and util files
	if err := os.WriteFile(WorkingDir+"/zz_client_util.go", []byte(s2), 0644); err != nil {
		return err
	}
	// write generated tests for core client utilities
	ctBody := strings.ReplaceAll(ClientTestConst, "\r\n", "\n")
	ctBody = strings.ReplaceAll(ctBody, "\r", "\n")
	ct := fmt.Sprintf("// %s\n\npackage %s\n\n%s", generatedHeader, PackageName, ctBody)
	if err := os.WriteFile(WorkingDir+"/zz_client_test.go", []byte(ct), 0644); err != nil {
		return err
	}
	cutBody := strings.ReplaceAll(ClientUtilTestConst, "\r\n", "\n")
	cutBody = strings.ReplaceAll(cutBody, "\r", "\n")
	cut := fmt.Sprintf("// %s\n\npackage %s\n\n%s", generatedHeader, PackageName, cutBody)
	if err := os.WriteFile(WorkingDir+"/zz_client_util_test.go", []byte(cut), 0644); err != nil {
		return err
	}
	return nil
}

// AddServiceTestFile generates unit tests for a service using httptest mock server
func AddServiceTestFile(service *api.WebService) error {
	if service == nil || len(service.Actions) == 0 {
		return nil
	}
	serviceName := service.Path[4:]
	serviceNameCamel := strcase.ToCamel(serviceName)

	f := NewFile(PackageName)
	f.HeaderComment(generatedHeader)
	f.ImportName("net/http", "http")
	f.ImportName("net/http/httptest", "httptest")
	f.ImportName("testing", "testing")
	f.ImportName("encoding/json", "json")

	// Generate test for each action
	for _, action := range service.Actions {
		actionName := strcase.ToCamel(action.Key)
		hasOption := len(action.Params) > 0

		// Determine if the method returns a response value (3 return values) or just (resp, err)
		// This must match the logic in GenerateGoContent
		method := "GET"
		if action.Post {
			method = "POST"
		}
		noResp := false
		switch action.ResponseType {
		case "json", "txt", "log", "svg", "xml", "proto":
			noResp = false
		case "no-content", "":
			noResp = true
		default:
			// For unknown response types, GET returns response, POST doesn't
			if method != "GET" {
				noResp = true
			}
		}
		hasResp := !noResp
		isProto := action.ResponseType == "proto"

		testFuncName := "Test" + serviceNameCamel + "_" + actionName

		f.Func().Id(testFuncName).Params(Id("t").Op("*").Qual("testing", "T")).BlockFunc(func(g *Group) {
			// Create mock server
			g.Comment("Create mock server")
			g.Id("ts").Op(":=").Qual("net/http/httptest", "NewServer").Call(
				Qual("net/http", "HandlerFunc").Call(
					Func().Params(Id("w").Qual("net/http", "ResponseWriter"), Id("r").Op("*").Qual("net/http", "Request")).BlockFunc(func(h *Group) {
						h.Comment("Verify request method")
						h.If(Id("r").Dot("Method").Op("!=").Lit(method)).Block(
							Id("t").Dot("Errorf").Call(Lit("expected method "+method+", got %s"), Id("r").Dot("Method")),
						)
						h.Comment("Return mock response")
						if isProto {
							// For proto responses, return 200 with valid JSON empty array
							// The Do function uses json.Decode for []byte type
							h.Id("w").Dot("Header").Call().Dot("Set").Call(Lit("Content-Type"), Lit("application/json"))
							h.Id("w").Dot("WriteHeader").Call(Lit(200))
							h.Id("w").Dot("Write").Call(Index().Byte().Call(Lit("[]")))
						} else if noResp {
							// No response body expected
							h.Id("w").Dot("WriteHeader").Call(Lit(204))
						} else {
							// Use null for JSON which is valid for any pointer/slice type
							h.Id("w").Dot("Header").Call().Dot("Set").Call(Lit("Content-Type"), Lit("application/json"))
							h.Id("w").Dot("WriteHeader").Call(Lit(200))
							h.Id("w").Dot("Write").Call(Index().Byte().Call(Lit("null")))
						}
					}),
				),
			)
			g.Defer().Id("ts").Dot("Close").Call()

			// Create client pointing to mock server
			g.Comment("Create client pointing to mock server")
			g.List(Id("client"), Id("err")).Op(":=").Id("NewClient").Call(Id("ts").Dot("URL").Op("+").Lit("/api/"), Lit("user"), Lit("pass"))
			g.If(Err().Op("!=").Nil()).Block(
				Id("t").Dot("Fatalf").Call(Lit("failed to create client: %v"), Err()),
			)

			// Call the service method
			g.Comment("Call service method")
			if hasOption {
				g.Id("opt").Op(":=").Op("&").Id(serviceNameCamel + strcase.ToCamel(action.Key) + "Option").Values()
				if hasResp {
					g.List(Id("_"), Id("resp"), Id("err")).Op(":=").Id("client").Dot(serviceNameCamel).Dot(actionName).Call(Id("opt"))
				} else {
					g.List(Id("resp"), Id("err")).Op(":=").Id("client").Dot(serviceNameCamel).Dot(actionName).Call(Id("opt"))
				}
			} else {
				if hasResp {
					g.List(Id("_"), Id("resp"), Id("err")).Op(":=").Id("client").Dot(serviceNameCamel).Dot(actionName).Call()
				} else {
					g.List(Id("resp"), Id("err")).Op(":=").Id("client").Dot(serviceNameCamel).Dot(actionName).Call()
				}
			}
			g.If(Err().Op("!=").Nil()).Block(
				Id("t").Dot("Fatalf").Call(Lit(actionName+" failed: %v"), Err()),
			)
			// Check expected status code
			expectedStatus := 200
			if noResp {
				expectedStatus = 204
			}
			g.If(Id("resp").Dot("StatusCode").Op("!=").Lit(expectedStatus)).Block(
				Id("t").Dot("Errorf").Call(Lit(fmt.Sprintf("expected status %d, got %%d", expectedStatus)), Id("resp").Dot("StatusCode")),
			)
		})
		f.Line()
	}

	return f.Save(WorkingDir + "/zz_" + serviceName + "_service_test.go")
}

func GenerateGoContent(packageName string, service *api.WebService) (f *File, err error) {
	if service == nil {
		return nil, errors.New("service must not be nil")
	}
	if packageName == "" {
		return nil, errors.New("package name is illegal")
	}
	f = NewFile(packageName)

	f.HeaderComment(generatedHeader)
	f.PackageComment(service.Description)
	f.ImportName("github.com/google/glog", "glog")

	name := service.Path[4:]
	//Create Service Struct
	f.Type().Id(strcase.ToCamel(name) + "Service").Struct(
		Id("client").Op("*").Id("Client"),
	).Line()

	//create main object
	fetcher := response.NewExampleFetcher(Endpoint, Username, Password)
	examples, err := fetcher.GetResponseExample(service)
	if err != nil {
		glog.Warningf("cannot fetch examples of <%s>: %v (continuing without examples)", service.Path, err)
		examples = make([]*response.WebservicesResponseExampleResp, 0)
		err = nil
		// When examples can't be fetched, we need to set default response types
		// for all actions so the code generator knows how to handle them
		for i := range service.Actions {
			// If ResponseType is not already set, we need to determine a default
			if service.Actions[i].ResponseType == "" {
				if service.Actions[i].Post {
					// POST requests without explicit response type typically return no body
					service.Actions[i].ResponseType = "no-content"
				} else {
					// GET requests default to JSON
					service.Actions[i].ResponseType = "json"
					// Only generate the struct if it's supposed to have a response example
					if service.Actions[i].HasResponseExample {
						respName := strcase.ToCamel(name + "_" + service.Actions[i].Key + "Object")
						f.Commentf("[TODO] cannot fetch response example for <%s>, struct needs to be filled manually", service.Actions[i].Key)
						f.Type().Id(respName).Struct().Line()
					}
				}
			}
		}
	}
	for _, exam := range examples {
		if exam.Format == "proto" {
			glog.V(1).Infof("The response of action <%s> for api <%s> is proto, using []byte", exam.Name, name)
			// Proto responses should be treated as binary data
			// Find the corresponding action and set its response type
			for i := range service.Actions {
				if service.Actions[i].Key == exam.Name {
					service.Actions[i].ResponseType = "proto"
					break
				}
			}
			continue
		}
		if exam.Format != "json" {
			glog.V(1).Infof("The response of action <%s> for api <%s> is %s, not json", exam.Name, name, exam.Format)
			continue
		}
		if exam.Example != "" {
			respName := strcase.ToCamel(name + "_" + exam.Name + "Object")
			stru, err := ConvertStringToStruct(exam.Example, respName)
			if err != nil {
				glog.Warningf("cannot generate resp struct of <%s>,you should manual edit the file %s,esspecial method response", service.Path, WorkingDir+"/zz_"+name+"_service.go")
				glog.Errorln(err.Error())
				err = nil
				//because of the api is not normative,so we should ignore the error
				f.Commentf("[TODO] cannot generate resp struct of <%s>,you should manual edit the file %s,esspecial method response", service.Path, WorkingDir+"/zz_"+name+"_service.go")
				f.Type().Id(respName).Struct().Line()
			} else {
				f.Id(stru).Line()
				f.Line()
			}
		}
	}
	//Create Methods
	for _, item := range service.Actions {
		f.Add(GenerateServiceActionContent(name, &item))
	}
	return
}
func detectDeprecatedField(field *api.Param) bool {
	if strings.Contains(strings.ToLower(field.Description), "deprecated") {
		return true
	}
	return false
}

// GenerateServiceActionContent generate code of each service,include api method and related structs
func GenerateServiceActionContent(serviceName string, action *api.Action) *Statement {
	c := Line()
	hasOption := true
	optionName := strcase.ToCamel(serviceName + "_" + action.Key + "Option")
	respName := strcase.ToCamel(serviceName + "_" + action.Key + "Object")
	if len(action.Params) == 0 {
		hasOption = false
	}

	if hasOption {
		c.Type().Id(optionName).StructFunc(func(g *Group) {
			for _, field := range action.Params {
				if detectDeprecatedField(&field) {
					glog.V(1).Infof("Detected deprecated field <%s> in <action>:%s,description:%s\n", field.Key, action.Key, field.Description)
					continue
				}
				g.Id(strcase.ToCamel(field.Key)).String().Tag(map[string]string{"url": field.Key + ",omitempty"}).Commentf("Description:\"%s\",ExampleValue:\"%s\"", field.Description, field.ExampleValue)
			}
		}).Line()

		//create valid method
		validation.Func().Params(Id("s").Op("*").Id(strcase.ToCamel(serviceName) + "Service")).Id("Validate" + strcase.ToCamel(action.Key) + "Opt").Params(
			Id("opt").Op("*").Id(optionName)).Params(Error()).Block(
			Return(Nil()),
		)
	}
	//create method
	method := "GET"
	noResp := false
	if action.Post {
		method = "POST"
	}
	c.Commentf("%s %s", strcase.ToCamel(action.Key), action.Description).Line()
	c.Func().Params(Id("s").Op("*").Id(strcase.ToCamel(serviceName) + "Service")).Id(strcase.ToCamel(action.Key)).ParamsFunc(func(g *Group) {
		if hasOption {
			g.Id("opt").Op("*").Id(optionName)
		}
	}).ParamsFunc(func(g *Group) {
		switch action.ResponseType {
		case "json":
			g.Id("v").Op("*").Id(respName)
		case "txt", "log", "svg", "xml":
			g.Id("v").Op("*").String()
			respName = "string"
		case "proto":
			// Protocol Buffer binary data
			g.Id("v").Op("[]").Byte()
			respName = "[]byte"
		case "no-content", "":
			// No response body expected
			noResp = true
		default:
			if method == "GET" {
				g.Id("v").Op("*").Id(respName)
			} else {
				noResp = true
			}
		}
		g.Id("resp").Op("*").Qual("net/http", "Response")
		g.Err().Error()
	}).BlockFunc(func(g *Group) {
		if hasOption {
			g.Err().Op("=").Id("s").Dot("Validate" + strcase.ToCamel(action.Key) + "Opt").Call(Id("opt"))
			ErrorHandlerHelper(g)
		}
		g.List(Id("req"), Id("err")).Op(":=").Id("s").Dot("client").Dot("NewRequest").CallFunc(func(g *Group) {
			g.Lit(method)
			g.Lit(serviceName + "/" + action.Key)
			if hasOption {
				g.Id("opt")
			} else {
				g.Nil()
			}
		})
		ErrorHandlerHelper(g)
		if noResp {
			g.List(Id("resp"), Err()).Op("=").Id("s").Dot("client").Dot("Do").Call(Id("req"), Nil())
			ErrorHandlerHelper(g)
		} else if action.ResponseType == "proto" {
			// For proto responses, don't use New() since v is []byte not a pointer
			g.List(Id("resp"), Err()).Op("=").Id("s").Dot("client").Dot("Do").Call(Id("req"), Op("&").Id("v"))
			g.If(
				Err().Op("!=").Nil(),
			).Block(
				Return().List(Nil(), Id("resp"), Err()),
			)
		} else {
			g.Id("v").Op("=").New(Id(respName))
			g.List(Id("resp"), Err()).Op("=").Id("s").Dot("client").Dot("Do").Call(Id("req"), Id("v"))
			g.If(
				Err().Op("!=").Nil(),
			).Block(
				Return().List(Nil(), Id("resp"), Err()),
			)
		}
		g.Return()
	})
	return c
}

func ErrorHandlerHelper(g *Group) {
	g.If(
		Err().Op("!=").Nil(),
	).Block(
		Return(),
	)
}

// GetCurrentModulePath reads the module path from go.mod file.
// This replaces the legacy GOPATH-based approach.
func GetCurrentModulePath() (string, error) {
	// Read go.mod file
	data, err := os.ReadFile("go.mod")
	if err != nil {
		return "", fmt.Errorf("failed to read go.mod: %w (make sure you're in a Go module directory)", err)
	}

	// Parse module path from go.mod
	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			modulePath := strings.TrimSpace(strings.TrimPrefix(line, "module"))
			if modulePath == "" {
				return "", errors.New("module path is empty in go.mod")
			}
			return modulePath, nil
		}
	}

	return "", errors.New("module directive not found in go.mod")
}
